<div class="h-full py-8 px-7 overflow-y-auto bg-blue-300">
<article class="max-w-lg m-6 mt-4 bg-white rounded-md mb-12">
  <h1 class="text-4xl text-gray-800 text-center font-bold leading-8 py-9">
    Utility-First
  </h1>
  <p class="text-gray-800 px-6 py-4 text-base">
    Traditionally, whenever you need to style something on the web, you write CSS. With Tailwind, you style elements by applying pre-existing classes directly in your HTML.
  </p>
  <p class="text-gray-800 px-6 py-4 text-base">
    Once you've actually built something this way, you'll quickly notice some really important benefits:
  </p>
  <ul class="text-gray-800 ml-14 text-base list-disc">
    <li>
      You aren't wasting energy inventing class names.
    </li>
    <li>
      Your CSS stops growing.
    </li>
    <li>
      Making changes feels safer.
    </li>
  </ul>
  <p class="text-gray-800 px-6 py-4 text-base">
    When you realize how productive you can be working exclusively in HTML with predefined utility classes, working any other way will feel like torture.
  </p>
  <p class="text-gray-800 px-6 py-4 text-base">
    The biggest maintainability concern when using a utility-first approach is managing commonly repeated utility combinations. This is easily solved by extracting components, either as template partials/JavaScript components, or using Tailwind's @apply feature to create abstractions around common utility patterns.
  </p>
  <p class="text-gray-800 px-6 py-4 text-base">
    Aside from that, maintaining a utility-first CSS project turns out to be a lot easier than maintaining a large CSS codebase, simply because HTML is so much easier to maintain than CSS. Large companies like GitHub, Heroku, Kickstarter, Twitch, Segment, and more are using this approach with great success.
  </p>
</article>
</div>